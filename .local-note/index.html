<h1 id="introduction">Introduction</h1>
<p> Sorting algorithms are fundamental in computer science and play a crucial role in organizing data efficiently.
    In
    this article, we will explore various sorting algorithms, comparing their performance and providing a brief
    overview
    of their complexities and code implementations.</p>

<h1 id="BubbleSort">Bubble Sort</h1>

<h2 id="BubbleSortComplexity">Complexity</h2>
<p>
    Time Complexity: O(n<sup>2</sup>) in the worst and average cases, O(n) in the best case.
    Space Complexity: O(1).
</p>
<h2 id="BubbleSortOverView" >Overview</h2>
<p>
    Bubble Sort iterates through the list, comparing adjacent elements and swapping them if they are in the wrong
    order.
    This process is repeated until the list is sorted.
</p>
```py
def bubble_sort(arr):
    n = len(arr)
    for i in range(n):
        for j in range(0, n-i-1):
            if arr[j] > arr[j+1]:
            arr[j], arr[j+1] = arr[j+1], arr[j]
```

<h1 id="InsertionSort">Insertion Sort</h1>

<h2 id="insertionSortComplexity">Complexity</h2>
<p>
    Time Complexity: O(n<sup>2</sup>) in the worst and average cases, O(n) in the best case.
    Space Complexity: O(1).
</p>
<h2>Overview</h2>
<p>
    Insertion Sort builds the final sorted array one item at a time, iterating through the input data and repeatedly
    moving the current element into its sorted position.
</p>
```py
def insertion_sort(arr):
    for i in range(1, len(arr)):
    key = arr[i]
    j = i - 1
    while j >= 0 and key < arr[j]:
        arr[j + 1] = arr[j]
        j -= 1 
        arr[j + 1] = key
 ``` 
 <h1 id="MergeSort">Merge Sort</h1>
    <h2 id="MergeSortComplexity">Complexity</h2>
    <p>
        Time Complexity: O(n log n) in all cases.
        Space Complexity: O(n) for the auxiliary space used in merging.
    </p>
    <h2 id="MergeSortOverView">Overview</h2>
    <p>
        Merge Sort divides the unsorted list into n sublists, each containing one element, and then repeatedly
        merges
        sublists to produce new sorted sublists until there is only one sublist remaining.
    </p>

    ```py 
    def merge_sort(arr):
        if len(arr) > 1:
        mid = len(arr) // 2
        left_half = arr[:mid]
        right_half = arr[mid:]

        merge_sort(left_half)
        merge_sort(right_half)
        i = j = k = 0

    while i < len(left_half) and j < len(right_half):
        if left_half[i] < right_half[j]:
            arr[k] = left_half[i]
            i += 1
        else:
            arr[k] = right_half[j]
            j += 1
        k += 1

    while i < len(left_half):
        arr[k] = left_half[i]
        i += 1
        k += 1

    while j < len(right_half):
        arr[k] = right_half[j]
        j += 1
        k += 1
    ```
    <h1 id="Conclusion">Conclusion</h1>
    <p>
        Each sorting algorithm has its strengths and weaknesses. The choice of which to use depends on the specific requirements of the task at hand. Understanding the complexities and code overviews of these algorithms is essential for any programmer dealing with data manipulation and organization.
    </p>